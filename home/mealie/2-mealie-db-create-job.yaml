# 5a-create-app1-user-job.yaml (Corrected Script & Indentation)
apiVersion: batch/v1
kind: Job
metadata:
  name: create-mealie-db
  namespace: postgres # Run the job in the postgres namespace
  annotations:
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: "1"
spec:
  backoffLimit: 4 # Number of retries
  template: # Defines the Pod template
    spec: # Defines the Pod Specification within the template
      restartPolicy: OnFailure
      volumes:
      - name: postgres-ca-cert
        secret:
          secretName: postgres-db-ca # Example name, verify yours
      containers:
      - name: db-creator
        image: postgres:17 # Use a postgres client image
        env:
          # --- Env Vars from Secrets ---
          - name: APP_USER
            valueFrom: { secretKeyRef: { name: mealie-db-credentials, key: username } }
          - name: APP_PASSWORD
            valueFrom: { secretKeyRef: { name: mealie-db-credentials, key: password } }
          - name: APP_DB
            valueFrom: { secretKeyRef: { name: mealie-db-credentials, key: dbname } }
          - name: PGHOST
            valueFrom: { secretKeyRef: { name: mealie-db-credentials, key: host } }
          - name: PGPORT
            valueFrom: { secretKeyRef: { name: mealie-db-credentials, key: port } }
          - name: PGUSER
            valueFrom:
              secretKeyRef:
                name: postgres-db-superuser
                key: username
          - name: PGPASSWORD
            valueFrom:
              secretKeyRef:
                name: postgres-db-superuser
                key: password
          - name: PGDATABASE
            value: "postgres"
          - name: PGSSLMODE
            value: "verify-full"
          - name: PGSSLROOTCERT
            value: "/etc/ssl/certs/postgres-ca/ca.crt"
          # --- End Env Vars ---

        volumeMounts:
          - name: postgres-ca-cert
            mountPath: "/etc/ssl/certs/postgres-ca"
            readOnly: true

        command: ["bash", "-ec"]
        args:
          - |
            echo "Attempting to create database ${APP_DB} and user ${APP_USER}..."

            if ! psql -tAc "SELECT 1 FROM pg_user WHERE usename = '${APP_USER}'" | grep -q 1; then
              echo "User ${APP_USER} does not exist. Creating..."
              psql -c "CREATE USER \"${APP_USER}\" WITH PASSWORD '${APP_PASSWORD}';"
            else
              echo "User ${APP_USER} already exists."
            fi

            db_exists_result=$(psql -tAc "SELECT EXISTS (SELECT 1 FROM pg_database WHERE datname = '${APP_DB}')")

            if [ "${db_exists_result}" != "t" ]; then
              echo "Database ${APP_DB} does not exist. Creating..."
              psql -c "CREATE DATABASE \"${APP_DB}\" OWNER \"${APP_USER}\";"
            else
              echo "Database ${APP_DB} already exists."
            fi

            echo "Granting privileges for ${APP_USER} on ${APP_DB}..."
            psql -c "GRANT ALL PRIVILEGES ON DATABASE \"${APP_DB}\" TO \"${APP_USER}\";"

            # Connect to the specific DB to grant schema permissions
            export PGDATABASE=${APP_DB}
            psql -c "GRANT USAGE, CREATE ON SCHEMA public TO \"${APP_USER}\";"
            psql -c "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"${APP_USER}\";"
            psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON TABLES TO \"${APP_USER}\";"
            psql -c "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"${APP_USER}\";"
            psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL PRIVILEGES ON SEQUENCES TO \"${APP_USER}\";"

            echo "Database ${APP_DB} and user ${APP_USER} setup complete."